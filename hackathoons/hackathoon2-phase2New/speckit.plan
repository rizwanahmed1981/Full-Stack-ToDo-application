# Implementation Plan: In-Memory Console Todo Application

## Project Structure
```
todo_app/
├── main.py                 # Entry point
├── app/
│   ├── __init__.py
│   ├── todo/
│   │   ├── __init__.py
│   │   ├── models.py       # Todo model definitions
│   │   ├── service.py      # Business logic and todo operations
│   │   └── presenter.py    # Console interface and user interaction
│   └── utils/
│       ├── __init__.py
│       └── cli.py          # Command line parsing
└── tests/
    ├── __init__.py
    ├── test_models.py
    ├── test_service.py
    └── test_presenter.py
```

## Implementation Steps

### Phase 1: Core Models and Data Layer
1. Create Todo model with id, task, and completed attributes
2. Implement in-memory storage for todos
3. Define data structures for storing and retrieving todos

### Phase 2: Service Layer Implementation
1. Implement CRUD operations in service layer
2. Add functionality to mark todos as complete
3. Implement clear all todos functionality
4. Add proper error handling and validation

### Phase 3: Presentation Layer
1. Create console interface for user interaction
2. Implement command parsing and execution
3. Add help and quit functionality
4. Format and display todos properly

### Phase 4: Testing
1. Write unit tests for models
2. Write unit tests for service layer
3. Write unit tests for presentation layer
4. Test all command functionality

### Phase 5: Main Application Flow
1. Connect all layers together
2. Implement main application loop
3. Handle user input and command execution
4. Add graceful error handling

## Class and Method Specifications

### Todo Model
- `Todo(id: int, task: str, completed: bool = False)`
- Properties: id, task, completed

### TodoService
- `create(task: str) -> Todo`
- `get_all() -> List[Todo]`
- `get_by_id(id: int) -> Todo`
- `update(id: int, task: str) -> Todo`
- `delete(id: int) -> bool`
- `complete(id: int) -> bool`
- `clear() -> None`

### TodoPresenter
- `display_todos(todos: List[Todo])`
- `display_message(message: str)`
- `get_user_input() -> str`
- `handle_command(command: str) -> bool`

## Command Processing Flow
1. Parse user input into command and arguments
2. Validate command and arguments
3. Call appropriate service methods
4. Display results or error messages
5. Loop until quit command is received